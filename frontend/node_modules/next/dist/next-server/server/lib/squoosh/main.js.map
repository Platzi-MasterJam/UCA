{"version":3,"sources":["../../../../../next-server/server/lib/squoosh/main.ts"],"names":["getWorker","Worker","path","resolve","__dirname","enableWorkerThreads","numWorkers","Math","max","min","length","computeWorkerKey","method","processBuffer","buffer","operations","encoding","quality","worker","imageData","decodeBuffer","operation","type","rotate","numRotations","width","resize","Buffer","from","encodeJpeg","encodeWebp","encodePng","Error"],"mappings":"yEAAA,uCACA,kDACA,yCACA,sB,qzBAaA,KAAMA,CAAAA,SAAS,CAAG,oBAChB,IACE,GAAIC,mBAAJ,CAAWC,IAAI,CAACC,OAAL,CAAaC,SAAb,CAAwB,MAAxB,CAAX,CAA4C,CAC1CC,mBAAmB,CAAE,IADqB,CAE1C;AACA;AACAC,UAAU,CAAEC,IAAI,CAACC,GAAL,CAAS,CAAT,CAAYD,IAAI,CAACE,GAAL,CAAS,eAAOC,MAAP,CAAgB,CAAzB,CAA4B,CAA5B,CAAZ,CAJ8B,CAK1CC,gBAAgB,CAAGC,MAAD,EAAYA,MALY,CAA5C,CAFc,CAAlB,CAWO,cAAeC,CAAAA,aAAf,CACLC,MADK,CAELC,UAFK,CAGLC,QAHK,CAILC,OAJK,CAKY,CACjB,KAAMC,CAAAA,MAA+B,CAAGlB,SAAS,EAAjD,CAEA,GAAImB,CAAAA,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACE,YAAP,CAAoBN,MAApB,CAAtB,CACA,IAAK,KAAMO,CAAAA,SAAX,GAAwBN,CAAAA,UAAxB,CAAoC,CAClC,GAAIM,SAAS,CAACC,IAAV,GAAmB,QAAvB,CAAiC,CAC/BH,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACK,MAAP,CAAcJ,SAAd,CAAyBE,SAAS,CAACG,YAAnC,CAAlB,CACD,CAFD,IAEO,IAAIH,SAAS,CAACC,IAAV,GAAmB,QAAvB,CAAiC,CACtC,GAAIH,SAAS,CAACM,KAAV,EAAmBN,SAAS,CAACM,KAAV,CAAkBJ,SAAS,CAACI,KAAnD,CAA0D,CACxDN,SAAS,CAAG,KAAMD,CAAAA,MAAM,CAACQ,MAAP,CAAcP,SAAd,CAAyBE,SAAS,CAACI,KAAnC,CAAlB,CACD,CACF,CACF,CAED,OAAQT,QAAR,EACE,IAAK,MAAL,CACE,MAAOW,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAMV,CAAAA,MAAM,CAACW,UAAP,CAAkBV,SAAlB,CAA6B,CAAEF,OAAF,CAA7B,CAAlB,CAAP,CACF,IAAK,MAAL,CACE,MAAOU,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAMV,CAAAA,MAAM,CAACY,UAAP,CAAkBX,SAAlB,CAA6B,CAAEF,OAAF,CAA7B,CAAlB,CAAP,CACF,IAAK,KAAL,CACE,MAAOU,CAAAA,MAAM,CAACC,IAAP,CAAY,KAAMV,CAAAA,MAAM,CAACa,SAAP,CAAiBZ,SAAjB,CAAlB,CAAP,CACF,QACE,KAAMa,CAAAA,KAAK,CAAE,6BAAF,CAAX,CARJ,CAUD","sourcesContent":["import { Worker } from 'jest-worker'\nimport * as path from 'path'\nimport { execOnce } from '../../../lib/utils'\nimport { cpus } from 'os'\n\ntype RotateOperation = {\n  type: 'rotate'\n  numRotations: number\n}\ntype ResizeOperation = {\n  type: 'resize'\n  width: number\n}\nexport type Operation = RotateOperation | ResizeOperation\nexport type Encoding = 'jpeg' | 'png' | 'webp'\n\nconst getWorker = execOnce(\n  () =>\n    new Worker(path.resolve(__dirname, 'impl'), {\n      enableWorkerThreads: true,\n      // There will be at most 6 workers needed since each worker will take\n      // at least 1 operation type.\n      numWorkers: Math.max(1, Math.min(cpus().length - 1, 6)),\n      computeWorkerKey: (method) => method,\n    })\n)\n\nexport async function processBuffer(\n  buffer: Buffer,\n  operations: Operation[],\n  encoding: Encoding,\n  quality: number\n): Promise<Buffer> {\n  const worker: typeof import('./impl') = getWorker() as any\n\n  let imageData = await worker.decodeBuffer(buffer)\n  for (const operation of operations) {\n    if (operation.type === 'rotate') {\n      imageData = await worker.rotate(imageData, operation.numRotations)\n    } else if (operation.type === 'resize') {\n      if (imageData.width && imageData.width > operation.width) {\n        imageData = await worker.resize(imageData, operation.width)\n      }\n    }\n  }\n\n  switch (encoding) {\n    case 'jpeg':\n      return Buffer.from(await worker.encodeJpeg(imageData, { quality }))\n    case 'webp':\n      return Buffer.from(await worker.encodeWebp(imageData, { quality }))\n    case 'png':\n      return Buffer.from(await worker.encodePng(imageData))\n    default:\n      throw Error(`Unsupported encoding format`)\n  }\n}\n"]}